(()=>{async function E(e){if(e.length===0)throw new Error("tabs is empty");const t=e.slice(0,100),s=[];for(const o of t)o.title==null||o.id==null||!o.url||s.push({id:o.id,title:o.title,domain:y(o.url)});return`I want you can help me to grounping my tabs. I will give you some titles, ids, and URLs of tabs.
I want you to group my tabs and the group cannot exceed 10.
And I want you to only reply the group name and ids array with json format, and nothing else.
The group name is as short as possible and is not a url if possible.
The Format is [{group_name: string, ids: number[]}]
Do not write explanations. Do not type other word.
My url list is ${JSON.stringify(s)}`}function y(e){try{return new URL(e).hostname}catch{return console.error("Failed to parse URL:",e),null}}async function _(e,t){if(e.length===0)throw new Error("tabs is empty");const s=e.slice(0,100),o=[];for(const a of s)a.title==null||a.id==null||!a.url||o.push({id:a.id,title:a.title,groupId:a.groupId,domain:y(a.url)});const r=t.slice(0,100),d=[];for(const a of r){if(a.title==null||a.id==null)continue;const n=a.title.startsWith("\u{1F916} | ")?a.title.slice(5):a.title;d.push({id:a.id,title:n})}return`I want you can help me to grounping my tabs. I will give you some titles, ids, and URLs of tabs.
I want you to group my tabs and the group cannot exceed 10.
And I want you to only reply the group id, group name and ids array with json format, and nothing else.
If group is not exist, you can make group id to -1 to create group.
The group name is as short as possible and is not a url if possible. Reuse the group is better. Don't make "Other" group.
Just return only what has changed.
The Format is [{group_id: number, group_name: string, ids: number[]}]
Do not write explanations. Do not type other word.
My url list is ${JSON.stringify(o)}
My group list is ${JSON.stringify(d)}`}const $=(e,t,s,o)=>function(...r){const d=t.promiseModule;return new d((a,n)=>{t.multiArgs?r.push((...c)=>{t.errorFirst?c[0]?n(c):(c.shift(),a(c)):a(c)}):t.errorFirst?r.push((c,i)=>{c?n(c):a(i)}):r.push(a),Reflect.apply(e,this===s?o:this,r)})},x=new WeakMap;function k(e,t){t={exclude:[/.+(?:Sync|Stream)$/],errorFirst:!0,promiseModule:Promise,...t};const s=typeof e;if(!(e!==null&&(s==="object"||s==="function")))throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${e===null?"null":s}\``);const o=(a,n)=>{let l=x.get(a);if(l||(l={},x.set(a,l)),n in l)return l[n];const c=h=>typeof h=="string"||typeof n=="symbol"?n===h:h.test(n),i=Reflect.getOwnPropertyDescriptor(a,n),u=i===void 0||i.writable||i.configurable,m=(t.include?t.include.some(h=>c(h)):!t.exclude.some(h=>c(h)))&&u;return l[n]=m,m},r=new WeakMap,d=new Proxy(e,{apply(a,n,l){const c=r.get(a);if(c)return Reflect.apply(c,n,l);const i=t.excludeMain?a:$(a,t,d,a);return r.set(a,i),Reflect.apply(i,n,l)},get(a,n){const l=a[n];if(!o(a,n)||l===Function.prototype[n])return l;const c=r.get(l);if(c)return c;if(typeof l=="function"){const i=$(l,t,d,a);return r.set(l,i),i}return l}});return d}var G=()=>{try{let e=navigator.userAgent;if((e.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i)||[])[1]==="Chrome"){let t=e.match(/\b(OPR|Edge)\/(\d+)/);if(t)return parseInt(t[2])<100}}catch{return!1}return!1},L=class{#s;#e;get primaryClient(){return this.#e}#t;get secondaryClient(){return this.#t}#o;get area(){return this.#o}get hasWebApi(){try{return typeof window<"u"&&!!window.localStorage}catch(e){return console.error(e),!1}}#a=new Map;#n;get copiedKeySet(){return this.#n}isCopied=e=>this.hasWebApi&&(this.allCopied||this.copiedKeySet.has(e));#r=!1;get allCopied(){return this.#r}getExtStorageApi=()=>globalThis.browser?.storage||globalThis.chrome?.storage;get hasExtensionApi(){try{return!!this.getExtStorageApi()}catch(e){return console.error(e),!1}}isWatchSupported=()=>this.hasExtensionApi;keyNamespace="";isValidKey=e=>e.startsWith(this.keyNamespace);getNamespacedKey=e=>`${this.keyNamespace}${e}`;getUnnamespacedKey=e=>e.slice(this.keyNamespace.length);constructor({area:e="sync",allCopied:t=!1,copiedKeyList:s=[]}={}){this.setCopiedKeySet(s),this.#o=e,this.#r=t;try{this.hasWebApi&&(t||s.length>0)&&(this.#t=window.localStorage)}catch{}try{this.hasExtensionApi&&(this.#s=this.getExtStorageApi(),G()?this.#e=k(this.#s[this.area],{exclude:["getBytesInUse"]}):this.#e=this.#s[this.area])}catch{}}setCopiedKeySet(e){this.#n=new Set(e)}getAll=()=>this.#e?.get();copy=async e=>{let t=e===void 0;if(!t&&!this.copiedKeySet.has(e)||!this.allCopied||!this.hasExtensionApi)return!1;let s=this.allCopied?await this.getAll():await this.#e.get(t?[...this.copiedKeySet]:[e]);if(!s)return!1;let o=!1;for(let r in s){let d=s[r],a=this.#t?.getItem(r);this.#t?.setItem(r,d),o||=d!==a}return o};rawGet=async e=>this.hasExtensionApi?(await this.#e.get(e))[e]:this.isCopied(e)?this.#t?.getItem(e):null;rawSet=async(e,t)=>(this.isCopied(e)&&this.#t?.setItem(e,t),this.hasExtensionApi&&await this.#e.set({[e]:t}),null);clear=async(e=!1)=>{e&&this.#t?.clear(),await this.#e.clear()};remove=async e=>{this.isCopied(e)&&this.#t?.removeItem(e),this.hasExtensionApi&&await this.#e.remove(e)};watch=e=>{let t=this.isWatchSupported();return t&&this.#i(e),t};#i=e=>{Object.entries(e).forEach(([t,s])=>{let o=this.getNamespacedKey(t),r=this.#a.get(o)?.callbackSet||new Set;if(r.add(s),r.size>1)return;let d=(a,n)=>{if(n!==this.area)return;let l=new Set(Object.keys(e)),c=Object.keys(a).filter(i=>l.has(i));c.length!==0&&Promise.all(c.map(async i=>{let u=this.#a.get(i),[g,m]=await Promise.all([this.parseValue(a[i].newValue),this.parseValue(a[i].oldValue)]);u?.callbackSet?.forEach(h=>h({newValue:g,oldValue:m},n))}))};this.#s.onChanged.addListener(d),this.#a.set(o,{callbackSet:r,listener:d})})};unwatch=e=>{let t=this.isWatchSupported();return t&&this.#c(e),t};#c(e){for(let[t,s]of Object.entries(e)){let o=this.getNamespacedKey(t);if(this.#a.has(o)){let r=this.#a.get(o);r.callbackSet.delete(s),r.callbackSet.size===0&&(this.#a.delete(o),this.#s.onChanged.removeListener(r.listener))}}}unwatchAll=()=>this.#d();#d(){this.#a.forEach(({listener:e})=>this.#s.onChanged.removeListener(e)),this.#a.clear()}},I=class extends L{get=async e=>{let t=this.getNamespacedKey(e),s=await this.rawGet(t);return this.parseValue(s)};set=async(e,t)=>{let s=this.getNamespacedKey(e),o=JSON.stringify(t);return this.rawSet(s,o)};setNamespace=e=>{this.keyNamespace=e};parseValue=async e=>{try{if(e!==void 0)return JSON.parse(e)}catch(t){console.error(t)}}};const v=new I({area:"sync"});let p;(function(e){e.Local="local",e.OpenAI="openai"})(p||(p={}));const T={provider:p.Local,configs:{openai:{token:""}}};async function M(){const e=await v.get("providerConfigs");return e===void 0?(console.log("config not found, use default config"),R(T),T):e}async function R(e){await v.set("providerConfigs",e)}class W{constructor(t){this.token=t}async generate(t){const s=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:"Bearer "+this.token},body:JSON.stringify({model:"gpt-4",messages:[{role:"user",content:t}]})});if(!s.ok)throw console.error(s),new Error("OpenAI API error");return(await s.json()).choices[0].message.content}async generateWithFormat(t){const s=await this.generate(t);return JSON.parse(s)}}async function S(){const e=await M();return e.provider,p.Local,p.OpenAI,new W(e.configs[p.OpenAI]?.token??"")}const C=new I({area:"sync"}),O={showName:!0,autoGroup:!0};async function w(){const e=await C.get("settings");return e===void 0?(console.log("settings not found, use default settings"),K(O),O):e}async function K(e){await C.set("settings",e)}async function N(e){const t=w(),s=e??(await chrome.windows.getCurrent()).id;if(s===void 0)return!1;const o=await chrome.tabs.query({windowId:s}),r=[];for(const i of o)i.id!==void 0&&r.push(i.id);chrome.tabs.ungroup(r),console.log("ungrouping all tabs");const d=E(o),a=S(),n=new Date().getTime(),l=setInterval(()=>{const i=new Date().getTime(),u=Math.floor((i-n)/1e3).toString();chrome.action.setBadgeText({text:u})},1e3);let c=[];try{const i=await(await a).generate(await d);c=await JSON.parse(i)}catch(i){return console.log(i),clearInterval(l),chrome.action.setBadgeText({text:"Err"}),!1}return console.log(c),await P(c,s,(await t).showName),clearInterval(l),chrome.action.setBadgeText({text:""}),!0}async function P(e,t=chrome.windows.WINDOW_ID_CURRENT,s=!0){const o=await chrome.tabs.query({windowId:t});for(const d of e){switch(d.group_name){case"":case"Other":case"other":case"Others":case"others":case"Miscellaneous":case"miscellaneous":continue;default:break}const a=d.ids.filter(c=>o.find(i=>i.id===c));if(a.length===1||a.length===0)continue;const n=chrome.tabs.group({tabIds:a,createProperties:{windowId:t}}),l=await chrome.tabGroups.update(await n,{title:s?d.group_name:"\u{1F916}",collapsed:!0});console.log("Grouped ",l.title)}console.log("Grouped all tabs");const r=await chrome.tabs.query({windowId:t,groupId:chrome.tabGroups.TAB_GROUP_ID_NONE});for(const d of r)d.id!==void 0&&await chrome.tabs.move(d.id,{index:-1});console.log("Moved all non grouped tabs to the end")}var U=async(e,t)=>{await N(e.body.windowId),t.send({success:!0})};async function D(e){const t=await chrome.tabs.query({windowId:e??chrome.windows.WINDOW_ID_CURRENT});for(const s of t){if(s.id===void 0)return;await chrome.tabs.ungroup(s.id)}}var j=async(e,t)=>{await D(e.body.windowId),t.send({success:!0})};globalThis.__plasmoInternalPortMap=new Map,chrome.runtime.onMessage.addListener((e,t,s)=>{switch(e.name){case"groupAllTabs":U({sender:t,...e},{send:o=>s(o)});break;case"unGroupAllTabs":j({sender:t,...e},{send:o=>s(o)});break;default:break}return!0}),chrome.runtime.onConnect.addListener(function(e){globalThis.__plasmoInternalPortMap.set(e.name,e),e.onMessage.addListener(function(t){e.name})});class F{start(){this.startTime=new Date().getTime(),this.timer=Number(setInterval(()=>{const t=new Date().getTime(),s=Math.floor((t-this.startTime)/1e3).toString();chrome.action.setBadgeText({text:s})},1e3))}stop(){clearInterval(this.timer),this.startTime=0,chrome.action.setBadgeText({text:""})}error(){this.stop(),chrome.action.setBadgeText({text:"Err"})}}let b=!1;const f=[];function B(e){if(e.id===void 0)return;let t=f.findIndex(s=>s.windowId===e.windowId);t===-1&&(t=f.push({windowId:e.windowId,eventCount:0})-1),f[t].eventCount++,console.log(f[t].windowId,":",f[t].eventCount),!b&&f[t].eventCount>=20&&(b=!0,f[t].eventCount=0,J(f[t].windowId))}async function J(e){const t=chrome.tabs.query({windowId:e,pinned:!1}),s=chrome.tabGroups.query({windowId:e}),o=S(),r=_(await t,await s),d=w(),a=new F;a.start();try{const n=await(await o).generateWithFormat(await r);await V(n,e,(await d).showName),a.stop()}catch(n){console.log(n),a.error()}b=!1}async function V(e,t=chrome.windows.WINDOW_ID_CURRENT,s=!0){const o=chrome.tabGroups.query({windowId:t}),r=await chrome.tabs.query({windowId:t});for(const a of e){switch(a.group_name){case"":case"Other":case"other":case"Others":case"others":case"Miscellaneous":case"miscellaneous":continue;default:break}const n=a.ids.filter(u=>r.find(g=>g.id===u));if(n.length===1||n.length===0)continue;const l=(await o).find(u=>u.id===a.group_id),c=chrome.tabs.group({tabIds:n,groupId:l!==void 0?a.group_id:void 0,createProperties:a.group_id===-1?{windowId:t}:void 0}),i=await chrome.tabGroups.update(await c,{title:s?a.group_name:"\u{1F916}"});console.log("Grouped ",i.title)}console.log("Grouped all tabs");const d=await chrome.tabs.query({windowId:t,groupId:chrome.tabGroups.TAB_GROUP_ID_NONE});for(const a of d)a.id!==void 0&&await chrome.tabs.move(a.id,{index:-1});console.log("Moved all non grouped tabs to the end")}console.log("\u{1F44B} Hi! Auto group tabs extension is running now!"),chrome.commands.onCommand.addListener(e=>{switch(e){case"ungroup-all-tabs":D();break;case"all-tabs":N();break;default:break}}),chrome.runtime.onInstalled.addListener(e=>{switch(e.reason){case"install":chrome.tabs.create({url:chrome.runtime.getURL("tabs/index.html")});break;default:break}}),chrome.tabs.onCreated.addListener(e=>{A(e)}),chrome.tabs.onUpdated.addListener((e,t,s)=>{t.status==="complete"&&A(s)});function A(e){(async t=>{(await w()).autoGroup&&B(t)})(e)}})();
